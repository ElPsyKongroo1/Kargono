#pragma once

#include "Kargono/Core/Base.h"
#include "Kargono/Math/Math.h"
#include "Modules/Assets/Asset.h"

#include <queue>
#include <string>

struct ALCdevice;
struct ALCcontext;

//============================================================
// Audio Namespace
//============================================================
// This namespace provides a location for audio related functionality.
//		The main use case of this namespace is playing audio through the
//		AudioEngine class. The audio engine needs to be initialized
//		with Init() and Terminate() to manage the underlying audio
//		implementation (OpenAL). The other notable exports of this
//		namespace are the AudioBuffers, AudioSources, and AudioListeners.
//		Currently, only the AudioBuffer is available for external use,
//		but is mostly managed by the AssetManager. There is an
//		AudioComponent in the Scene namespace that manages AudioBuffers
//		in the editor.
namespace Kargono::Audio
{
	class AudioService;
	class AudioBuffer;

	//==============================
	// Audio Source Spec Struct
	//==============================
	// This struct holds all of the information that fully describes a audio source
	//		when being played. This object is used when playing audio through the audio engine.
	//		This specification is provided to the PlayAudio() function.
	struct AudioSourceSpecification
	{
	public:
		Math::vec3 Position{};
		Math::vec3 Velocity{};
		float Pitch{1.0f};
		float Gain{1.0f};
		bool IsLooping{false};
		Ref<AudioBuffer> CurrentBuffer{nullptr};
	};

	//==============================
	// Audio Listener Spec Struct
	//==============================
	// This struct holds all of the information that fully describes a audio listener
	//		when being played. This object is used when playing audio through the audio engine.
	//		This specification is provided to the PlayAudio() function.
	struct AudioListenerSpecification
	{
	public:
		Math::vec3 Position{};
		Math::vec3 Velocity{};
		Math::vec3 Forward{1.0f, 0.0f, 0.0f};
		Math::vec3 Up{};
	};

	//============================================================
	// Audio Listener Class
	//============================================================
	// This class represents the object that receives sound from AudioSources.
	//		This class is a wrapper around a listener object that exists inside of
	//		OpenAL. Ex: An audio listener could be linked to the player character when
	//		a collision occurs. The source (the player being smacked with a rock)
	//		will produce a sound that the listener picks up. The algorithms that
	//		enable this process are encapsulated inside the OpenAL.
	class AudioListener
	{
	public:
		//==============================
		// Constructors and Destructors
		//==============================
		// There is currently no API for creating an audio listener in OpenAL.
		//		This will be implimented later... TODO
		AudioListener() = default;
	private:
		// m_Listener holds an actual reference to the AudioListener inside OpenAL.
		uint32_t m_ListenerID{ 0 };
	};
	//============================================================
	// Audio Buffer Class
	//============================================================
	// This class represents the finalized format for audio that can be attached to an
	//		AudioSource and played. This class exists as a wrapper around a buffer that
	//		exists in OpenAL Ex: A test.wav file can be loaded in as PCM data and loaded
	//		into an AudioBuffer. The AudioBuffer is now usable in the OpenAL context to
	//		be played!
	class AudioBuffer
	{
	public:
		//==============================
		// Constructors and Destructors
		//==============================
		// This constructor simply created a buffer inside OpenAL and stores a reference
		//		to that buffer in m_BufferID.
		AudioBuffer();
		// This destructor simply destroys the buffer inside of the OpenAL that is
		//		referenced by m_BufferID.
		~AudioBuffer();
	public:
		// This ID stores a reference to the OpenAL buffer that this class represents.
		uint32_t m_BufferID {0};

		friend Audio::AudioService;
	};

	//============================================================
	// Audio Source Class
	//============================================================
	// An audio source is a structure that represents the location where
	//		audio originates from. The AudioListener class will hear audio
	//		generated by an AudioSource. This class exists as a wrapper
	//		around an audio source object that exists inside OpenAL.
	class AudioSource
	{
	public:
		//==============================
		// Constructors and Destructors
		//==============================
		// This constructor simply creates an audio source inside of OpenAL
		//		and stores a reference to that source inside m_SourceID.
		AudioSource();
		// This destructor stops any audio currently playing from this source
		//		(which can cause some bugs) and destroys the current audio source
		//		referenced by m_SourceID.
		~AudioSource();
	public:
		//==============================
		// Getters/Setters
		//==============================
		uint32_t& GetSourceID() { return m_SourceID; }
	private:
		// This ID stores a reference to the OpenAL source that this class represents.
		uint32_t m_SourceID = 0;
	};


	//==============================
	// Audio Context Struct
	//==============================
	class AudioContext
	{
	public:
		//==============================
		// Constructors/Destructors
		//==============================
		AudioContext() = default;
		~AudioContext() = default;

		//==============================
		// LifeCycle Functions
		//==============================
		[[nodiscard]] bool Init();
		[[nodiscard]] bool Terminate();

		//==============================
		// Sound Playback
		//==============================
		void PlayStereoSound(Ref<AudioBuffer> audioBuffer);
		void PlayStereoSoundFromHandle(Assets::AssetHandle audioHandle);
		void PlaySound(const AudioSourceSpecification& sourceSpec, const AudioListenerSpecification& listenerSpec = {});
		void PlaySound(Ref<AudioBuffer> audioBuffer);
		void PlaySoundFromHandle(Assets::AssetHandle audioHandle);
		void StopAllAudio();
		//==============================
		// Manage Sound State
		//==============================
		void SetMute(bool isMute);
		
	private:
		//==============================
		// Internal Fields
		//==============================
		// Debug information
		std::string m_CurrentDeviceName{};
		// Audio context information
		ALCdevice* m_CurrentDeviceID{ nullptr };
		ALCcontext* m_ContextID{ nullptr };
		// Listeners and sources
		Scope<AudioListener> m_DefaultListener{ nullptr };
		std::queue<Ref<AudioSource>> m_AudioSourceQueue{};
		Scope<AudioSource> m_StereoMusicSource{ nullptr };
		// Local state
		bool m_Mute{ false };
	};

	class AudioService // TODO: REMOVE EWWWWWWW
	{
	public:
		//==============================
		// Create Audio Context
		//==============================
		static void CreateAudioContext()
		{
			// Initialize AudioContext
			if (!s_AudioContext)
			{
				s_AudioContext = CreateRef<Audio::AudioContext>();
			}

			// Verify init is successful
			KG_VERIFY(s_AudioContext, "Audio Service System Initiated");
		}
		static void RemoveAudioContext()
		{
			// Clear AudioContext
			s_AudioContext.reset();
			s_AudioContext = nullptr;

			// Verify terminate is successful
			KG_VERIFY(!s_AudioContext, "Audio Service System Initiated");
		}
		//==============================
		// Getters/Setters
		//==============================
		static AudioContext& GetActiveContext() { return *s_AudioContext; }
		static bool IsContextActive() { return (bool)s_AudioContext; }
	private:
		//==============================
		// Internal Fields
		//==============================
		static inline Ref<AudioContext> s_AudioContext{ nullptr };
	};
}
