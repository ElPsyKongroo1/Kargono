#pragma once

#include "Modules/ECS/EngineComponents.h"
#include "Modules/Events/PhysicsEvent.h"
#include "Kargono/Core/Timestep.h"
#include "Kargono/Core/Base.h"
#include "Modules/Physics2D/Physics2DCommon.h"

#include "Modules/Physics2D/ExternalAPI/Box2DAPI.h"

namespace Kargono::Scenes { class Scene; }

//============================================================
// Physics Namespace
//============================================================
// This namespace holds classes and structs to enable the usage of physics
//		in the engine. The main class is the Physics2DWorld which represents
//		the underlying physics library (Currently Box2D). The Physics2DWorld contains
//		a ContactListener which serves to subclass a b2ContactListener to receive
//		PhysicsCollisionEvents. The physics engine is tied to the active scene during
//		the runtime.
namespace Kargono::Physics
{
	//============================================================
	// Contact Listener Class
	//============================================================
	// This class enables the dispatching of collision events (generated by the PhysicsWorld)
	//		to the application event handling system. The contact listener is registered with
	//		the physics world and then receives collision events through the implemented function
	//		BeginContact. A Callback function is registered with the ContactListener during the
	//		construction of the physics world. The callback function is called during a collision event.
	class ContactListener : public b2ContactListener
	{
	public:
		//=========================
		// Constructor(s)
		//=========================
		// This constructor simply calls its parent class's constructor
		ContactListener();
		//=========================
		// Callback Event
		//=========================
		// This function sets the callback function that will be called with the PhysicsCollisionEvent
		//		as the parameter when a collision occurs.
		void SetEventCallback(const Events::EventCallbackFn& callback) { m_CallbackFunc = callback; }
		//=========================
		// Collision Detection
		//=========================
		// Implemented function that receives box2d physics event through V-table.
		virtual void BeginContact(b2Contact* contact) override;

		virtual void EndContact(b2Contact* contact) override;
	private:
		// Event callback function pointer
		Events::EventCallbackFn m_CallbackFunc;
	};

	//=========================
	// PhysicsSpecification
	//=========================
	// This specification is used to initialize the Physics2DWorld. Currently it only holds
	//		the gravity settings for the world.
	struct PhysicsSpecification
	{
		Math::vec2 Gravity = { 0.0f, 0.0f };
	};

	// This class captures the closest hit shape
	class RayCastCallback : public b2RayCastCallback
	{
	public:
		virtual float ReportFixture(b2Fixture* fixture, const b2Vec2& point,
			const b2Vec2& normal, float fraction) override;

		b2Fixture* m_Fixture { nullptr };
		b2Vec2 m_ContactPoint;
		b2Vec2 m_NormalVector;
		float m_Fraction;
	};

	//============================================================
	// Physics 2D World Class
	//============================================================
	class Physics2DWorld
	{
	public:
		//=========================
		// Constructors and Destructors
		//=========================
		// This constructor calls Box2D to initialize the underlying
		//		physics world and associates the context with m_PhysicsWorld.
		//		This constructor takes a few more steps including:
		//		1. Set the gravity settings, connect the m_ContactListener to
		//		its callback function, and create the physics world
		//		2. Find all entities in the active scene and register their
		//		default settings and their box/circle colliders.
		Physics2DWorld(Scenes::Scene* scene, const Math::vec2& gravity);
		// This destructor simply removes the current reference to the
		//		underlying physics world in m_PhysicsWorld
		~Physics2DWorld();

	private:
		// Underlying physics world implementation
		Scope<b2World> m_PhysicsWorld = nullptr;
		// This is a pointer to the active scene for use in the constructor and OnUpdate
		//		functions.
		Scenes::Scene* m_Scene = nullptr;
		// This contact listener moves physics collision events into the event pipeline
		//		for further processing.
		Scope<ContactListener> m_ContactListener = nullptr;
	private:
		friend class Physics2DService;
	};

	class Physics2DService
	{
	public:
		//=========================
		// Lifecycle Functions
		//=========================
		static void Init(Scenes::Scene* scene, PhysicsSpecification& physicsSpec);
		static void Terminate();

		//=========================
		// On Event Functionality
		//=========================
		static void OnUpdate(Timestep ts);

		//=========================
		// Interact with Physics2DWorld
		//=========================
		static RaycastResult Raycast(Math::vec2 startPoint, Math::vec2 endPoint);

		//=========================
		// Manage Active Physics2DWorld
		//=========================
		static void SetActiveGravity(const Math::vec2& gravity);

		//=========================
		// Getters/Setters
		//=========================
		static Ref<Physics2DWorld> GetActivePhysics2DWorld()
		{
			return s_ActivePhysicsWorld;
		}
	private:
		static inline Ref<Physics2DWorld> s_ActivePhysicsWorld { nullptr };
	};
}
