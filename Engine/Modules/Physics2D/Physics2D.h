#pragma once

#include "Modules/ECS/EngineComponents.h"
#include "Modules/Events/PhysicsEvent.h"
#include "Kargono/Core/Timestep.h"
#include "Kargono/Core/Base.h"
#include "Modules/Physics2D/Physics2DCommon.h"

#include "Modules/Physics2D/ExternalAPI/Box2DAPI.h"

namespace Kargono::Scenes { class Scene; }

//============================================================
// Physics Namespace
//============================================================
// This namespace holds classes and structs to enable the usage of physics
//		in the engine. The main class is the Physics2DWorld which represents
//		the underlying physics library (Currently Box2D). The Physics2DWorld contains
//		a ContactListener which serves to subclass a b2ContactListener to receive
//		PhysicsCollisionEvents. The physics engine is tied to the active scene during
//		the runtime.
namespace Kargono::Physics
{
	//============================================================
	// Contact Listener Class
	//============================================================
	// This class enables the dispatching of collision events (generated by the PhysicsWorld)
	//		to the application event handling system. The contact listener is registered with
	//		the physics world and then receives collision events through the implemented function
	//		BeginContact. A Callback function is registered with the ContactListener during the
	//		construction of the physics world. The callback function is called during a collision event.
	class ContactListener : public b2ContactListener
	{
	public:
		//=========================
		// Constructor(s)
		//=========================
		// This constructor simply calls its parent class's constructor
		ContactListener();
		//=========================
		// Callback Event
		//=========================
		// This function sets the callback function that will be called with the PhysicsCollisionEvent
		//		as the parameter when a collision occurs.
		void SetEventCallback(const Events::EventCallbackFn& callback) { m_CallbackFunc = callback; }
		//=========================
		// Collision Detection
		//=========================
		// Implemented function that receives box2d physics event through V-table.
		virtual void BeginContact(b2Contact* contact) override;

		virtual void EndContact(b2Contact* contact) override;
	private:
		// Event callback function pointer
		Events::EventCallbackFn m_CallbackFunc;
	};

	//=========================
	// PhysicsSpecification
	//=========================
	// This specification is used to initialize the Physics2DWorld. Currently it only holds
	//		the gravity settings for the world.
	struct PhysicsSpecification
	{
		Math::vec2 Gravity = { 0.0f, 0.0f };
	};

	// This class captures the closest hit shape
	class RayCastCallback : public b2RayCastCallback
	{
	public:
		virtual float ReportFixture(b2Fixture* fixture, const b2Vec2& point,
			const b2Vec2& normal, float fraction) override;

		b2Fixture* m_Fixture { nullptr };
		b2Vec2 m_ContactPoint;
		b2Vec2 m_NormalVector;
		float m_Fraction;
	};

	//============================================================
	// Physics 2D World Class
	//============================================================
	class Physics2DWorld
	{
	public:
		//=========================
		// Constructors and Destructors
		//=========================
		Physics2DWorld() = default;
		~Physics2DWorld() = default;
	public:
		//=========================
		// Lifecycle Functions
		//=========================
		[[nodiscard]] bool Init(Scenes::Scene* scene, PhysicsSpecification& physicsSpec);
		[[nodiscard]] bool Terminate();

		//=========================
		// On Event Functionality
		//=========================
		void OnUpdate(Timestep ts);

		//=========================
		// Interact with Physics2DWorld
		//=========================
		RaycastResult Raycast(Math::vec2 startPoint, Math::vec2 endPoint);

		//=========================
		// Manage Active Physics2DWorld
		//=========================
		void SetActiveGravity(const Math::vec2& gravity);

	private:
		//=========================
		// Internal Fields
		//=========================
		// Box2D world reference
		Scope<b2World> m_PhysicsWorld{ nullptr };
		// Callback API
		Scope<ContactListener> m_ContactListener{ nullptr };

		//=========================
		// Dependency Injection(s)
		//=========================
		Scenes::Scene* i_Scene{ nullptr };
	private:
		friend class Physics2DService;
	};

	class Physics2DService // TODO: REMOVE EWWWWWWW
	{
	public:
		//==============================
		// Create Physics2D Context
		//==============================
		static void CreatePhysics2DWorld()
		{
			// Initialize Physics2DWorld
			if (!s_Physics2DWorld)
			{
				s_Physics2DWorld = CreateRef<Physics::Physics2DWorld>();
			}

			// Verify init is successful
			KG_VERIFY(s_Physics2DWorld, "Physics2D Service System Initiated");
		}
		static void RemovePhysics2DWorld()
		{
			// Clear Physics2DWorld
			s_Physics2DWorld.reset();
			s_Physics2DWorld = nullptr;

			// Verify terminate is successful
			KG_VERIFY(!s_Physics2DWorld, "Physics2D Service System Initiated");
		}
		//==============================
		// Getters/Setters
		//==============================
		static Physics2DWorld& GetActiveContext() { return *s_Physics2DWorld; }
		static bool IsContextActive() { return (bool)s_Physics2DWorld; }
	private:
		//==============================
		// Internal Fields
		//==============================
		static inline Ref<Physics2DWorld> s_Physics2DWorld{ nullptr };
	};
}
