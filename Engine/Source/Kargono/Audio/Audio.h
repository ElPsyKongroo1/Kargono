#pragma once

#include "Kargono/Core/Base.h"
#include "Kargono/Math/Math.h"

#include <queue>
#include <string>

struct ALCdevice;
struct ALCcontext;
namespace Kargono::Assets { class AssetManager; }

//============================================================
// Audio Namespace
//============================================================
// This namespace provides a location for audio related functionality.
//		The main use case of this namespace is playing audio through the
//		AudioEngine class. The audio engine needs to be initialized
//		with Init() and Terminate() to manage the underlying audio
//		implementation (OpenAL). The other notable exports of this
//		namespace are the AudioBuffers, AudioSources, and AudioListeners.
//		Currently, only the AudioBuffer is available for external use,
//		but is mostly managed by the AssetManager. There is an
//		AudioComponent in the Scene namespace that manages AudioBuffers
//		in the editor.
namespace Kargono::Audio
{
	class AudioService;
	class AudioBuffer;

	//==============================
	// Audio Source Spec Struct
	//==============================
	// This struct holds all of the information that fully describes a audio source
	//		when being played. This object is used when playing audio through the audio engine.
	//		This specification is provided to the PlayAudio() function.
	struct AudioSourceSpecification
	{
	public:
		Math::vec3 Position{};
		Math::vec3 Velocity{};
		float Pitch{1.0f};
		float Gain{1.0f};
		bool IsLooping{false};
		Ref<AudioBuffer> CurrentBuffer{nullptr};
	};

	//==============================
	// Audio Listener Spec Struct
	//==============================
	// This struct holds all of the information that fully describes a audio listener
	//		when being played. This object is used when playing audio through the audio engine.
	//		This specification is provided to the PlayAudio() function.
	struct AudioListenerSpecification
	{
	public:
		Math::vec3 Position{};
		Math::vec3 Velocity{};
		Math::vec3 Forward{1.0f, 0.0f, 0.0f};
		Math::vec3 Up{};
	};

	//============================================================
	// Audio Listener Class
	//============================================================
	// This class represents the object that receives sound from AudioSources.
	//		This class is a wrapper around a listener object that exists inside of
	//		OpenAL. Ex: An audio listener could be linked to the player character when
	//		a collision occurs. The source (the player being smacked with a rock)
	//		will produce a sound that the listener picks up. The algorithms that
	//		enable this process are encapsulated inside the OpenAL.
	class AudioListener
	{
	public:
		//==============================
		// Constructors and Destructors
		//==============================
		// There is currently no API for creating an audio listener in OpenAL.
		//		This will be implimented later... TODO
		AudioListener() = default;
	private:
		// m_Listener holds an actual reference to the AudioListener inside OpenAL.
		uint32_t m_ListenerID{ 0 };
	};
	//============================================================
	// Audio Buffer Class
	//============================================================
	// This class represents the finalized format for audio that can be attached to an
	//		AudioSource and played. This class exists as a wrapper around a buffer that
	//		exists in OpenAL Ex: A test.wav file can be loaded in as PCM data and loaded
	//		into an AudioBuffer. The AudioBuffer is now usable in the OpenAL context to
	//		be played!
	class AudioBuffer
	{
	public:
		//==============================
		// Constructors and Destructors
		//==============================
		// This constructor simply created a buffer inside OpenAL and stores a reference
		//		to that buffer in m_BufferID.
		AudioBuffer();
		// This destructor simply destroys the buffer inside of the OpenAL that is
		//		referenced by m_BufferID.
		~AudioBuffer();
	private:
		// This ID stores a reference to the OpenAL buffer that this class represents.
		uint32_t m_BufferID {0};

		friend Audio::AudioService;
		friend Assets::AssetManager;
	};

	//============================================================
	// Audio Source Class
	//============================================================
	// An audio source is a structure that represents the location where
	//		audio originates from. The AudioListener class will hear audio
	//		generated by an AudioSource. This class exists as a wrapper
	//		around an audio source object that exists inside OpenAL.
	class AudioSource
	{
	public:
		//==============================
		// Constructors and Destructors
		//==============================
		// This constructor simply creates an audio source inside of OpenAL
		//		and stores a reference to that source inside m_SourceID.
		AudioSource();
		// This destructor stops any audio currently playing from this source
		//		(which can cause some bugs) and destroys the current audio source
		//		referenced by m_SourceID.
		~AudioSource();
	public:
		//==============================
		// Getters/Setters
		//==============================
		uint32_t& GetSourceID() { return m_SourceID; }
	private:
		// This ID stores a reference to the OpenAL source that this class represents.
		uint32_t m_SourceID = 0;
	};


	//==============================
	// Audio Context Struct
	//==============================
	struct AudioContext
	{
		// This name currently only exists for debugging purposes. It could be used
		//		for switching audio devices in future iterations.
		std::string CurrentDeviceName{};
		// m_CurrentDeviceID holds a reference to the OpenAL device struct that references
		//		a physical audio device on your hardware such as a headset.
		ALCdevice* CurrentDeviceID = nullptr;
		// m_ContextID holds a reference to the current OpenAL 'world'. This context is
		//		created around the selected audio device.
		ALCcontext* ContextID = nullptr;
		// This default listener is the regular listener for the newly created context.
		//		This is the listener all audio uses currently.
		Scope<AudioListener> DefaultListener = nullptr;
		// This queue holds all of the available audio source other than the stereo source.
		//		Audio is played by selected the source at the top of the queue, stopping any
		//		previous audio, playing the new audio, and pushing the source to the back
		//		of the queue. This allows sources to be cycled continuously.
		std::queue<Ref<AudioSource>> AudioSourceQueue{};
		// This is the default stereo source that plays continuous music. It is not interrupted
		//		by the other sources.
		Scope<AudioSource> StereoMusicSource = nullptr;
	};


	//============================================================
	// Audio Service Class
	//============================================================
	// This class represents the underlying context and lifecycle of the
	//		audio engine. Starting and closing the audio engine is tied
	//		to this class's lifetime. Most other actions involving audio
	//		are taken through this class including playing audio and
	//		stopping audio.
	class AudioService
	{
	public:
		//==============================
		// LifeCycle Functions
		//==============================
		// This function serves as the initiator for the OpenAL context.
		//		This function should only be called once when the application
		//		begins. Steps taken in this function include:
		//		1. Find and save current audio device (Think Primary Speakers)
		//		2. Create OpenAL context surrounding Audio Device
		//		3. Initialize the default listener.
		//		4. Initialize the audio source queue along with the stereo source.
		static void Init();
		// This function closes the OpenAL context. NOTE: Please close all open buffers
		//		before calling this function. Most if not all buffers should be managed
		//		by the asset system. This function takes the following actions:
		//		1. It closes the s_DefaultSourceSpec buffer
		//		2. It closes all of the audio sources including the queue and the stereo
		//		sources.
		//		3. The buffers inside the AssetManager are cleared.
		//		4. Finally the audio context and current device are cleared/destroyed.
		static void Terminate();

		//==============================
		// External Functionality
		//==============================
		// This function is currently unimplemented! This function should play requested
		//		stereo audio and take in a buffer.
		static void PlayStereoSound(Ref<AudioBuffer> audioBuffer);
		static void PlayStereoSoundFromName(const std::string& audioName);
		// This function is the main API for playing sound effects. The sourceSpec and
		//		listenerSpec allow for customization of concepts such as source/listener
		//		distance, source volume, source pitch, relative velocities (doppler effect),
		//		etc... This function takes these values into account and plays a sound.
		static void PlaySound(const AudioSourceSpecification& sourceSpec, const AudioListenerSpecification& listenerSpec = {});
		// This function provides an easy API for playing sound where the source/listener
		//		are at an identical location and uses default values for other parameters.
		//		The API simply needs to know what audio should be played! This function
		//		calls the other PlaySound function with default values btw.
		static void PlaySound(Ref<AudioBuffer> audioBuffer);
		static void PlaySoundFromName(const std::string& audioName);
		// This function provides a method to stop all audio from playing. This function
		//		function simply iterates through the audio source queue and stops any
		//		audio currently playing.
		static void StopAllAudio();
	public:
		//==============================
		// Constructors and Destructors
		//==============================
		// This is just the default constructor. The audio engine is a singleton
		//		that is static for the program.
		AudioService() = default;
	private:
		// This is the actual AudioEngine which is staticly created in the AudioEngine.cpp file
		//		and is active through the lifetime of the application. Init() and Terminate()
		//		dictate if OpenAL is active.
		static AudioContext* s_AudioContext;
	};
}
