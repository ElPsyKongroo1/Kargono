#pragma once

#include "Kargono/Scene/Components.h"
#include "Kargono/Events/ApplicationEvent.h"
#include "Kargono/Core/Timestep.h"
#include "Kargono/Core/Base.h"
#include "Kargono/Math/Math.h"

#include "box2d/b2_body.h"
#include "box2d/b2_world_callbacks.h"

namespace Kargono { class Scene; }

//============================================================
// Physics Namespace
//============================================================
// This namespace holds classes and structs to enable the usage of physics
//		in the engine. The main class is the Physics2DWorld which represents
//		the underlying physics library (Currently Box2D). The Physics2DWorld contains
//		a ContactListener which serves to subclass a b2ContactListener to receive
//		PhysicsCollisionEvents. The physics engine is tied to the active scene during
//		the runtime.
namespace Kargono::Physics
{
	//============================================================
	// Contact Listener Class
	//============================================================
	// This class enables the dispatching of collision events (generated by the PhysicsWorld)
	//		to the application event handling system. The contact listener is registered with
	//		the physics world and then receives collision events through the implemented function
	//		BeginContact. A Callback function is registered with the ContactListener during the
	//		construction of the physics world. The callback function is called during a collision event.
	class ContactListener : public b2ContactListener
	{
	public:
		//=========================
		// Constructor(s)
		//=========================
		// This constructor simply calls its parent class's constructor
		ContactListener();
		//=========================
		// Callback Event
		//=========================
		// This function sets the callback function that will be called with the PhysicsCollisionEvent
		//		as the parameter when a collision occurs.
		void SetEventCallback(const Events::EventCallbackFn& callback) { m_CallbackFunc = callback; }
		//=========================
		// Collision Detection
		//=========================
		// Implemented function that receives box2d physics event through V-table.
		virtual void BeginContact(b2Contact* contact) override;
	private:
		// Event callback function pointer
		Events::EventCallbackFn m_CallbackFunc;
	};

	//=========================
	// PhysicsSpecification
	//=========================
	// This specification is used to initialize the Physics2DWorld. Currently it only holds
	//		the gravity settings for the world.
	struct PhysicsSpecification
	{
		Math::vec2 Gravity = { 0.0f, 0.0f };
	};

	//============================================================
	// Physics 2D World Class
	//============================================================
	class Physics2DWorld
	{
	public:
		//=========================
		// Constructors and Destructors
		//=========================
		// This constructor calls Box2D to initialize the underlying
		//		physics world and associates the context with m_PhysicsWorld.
		//		This constructor takes a few more steps including:
		//		1. Set the gravity settings, connect the m_ContactListener to
		//		its callback function, and create the physics world
		//		2. Find all entities in the active scene and register their
		//		default settings and their box/circle colliders.
		Physics2DWorld(Scene* scene, const Math::vec2& gravity);
		// This destructor simply removes the current reference to the
		//		underlying physics world in m_PhysicsWorld
		~Physics2DWorld();

		//=========================
		// LifeCycle Functions
		//=========================
		// This function iterates the position and velocity of current physics
		//		world objects through the Step function and updates the transforms
		//		of all entities in the scene that involve physics.
		void OnUpdate(Timestep ts);
		//=========================
		// Update Underlying Physics World
		//=========================
		// This function simply sets the gravity settings of the active physics world.
		void SetGravity(const Math::vec2& gravity);
	private:
		// Underlying physics world implementation
		Scope<b2World> m_PhysicsWorld = nullptr;
		// This is a pointer to the active scene for use in the constructor and OnUpdate
		//		functions.
		Scene* m_Scene = nullptr;
		// This contact listener moves physics collision events into the event pipeline
		//		for further processing.
		Scope<ContactListener> m_ContactListener = nullptr;
	};
}

namespace Kargono::Utility
{
	//============================================================
	// Conversion Functions
	//============================================================
	// These functions to convert between box2d enums and Kargono BodyType enums enums

	inline static b2BodyType Rigidbody2DTypeToBox2DBody(Rigidbody2DComponent::BodyType bodyType)
	{
		switch (bodyType)
		{
		case Rigidbody2DComponent::BodyType::Static:	return b2_staticBody;
		case Rigidbody2DComponent::BodyType::Dynamic:	return b2_dynamicBody;
		case Rigidbody2DComponent::BodyType::Kinematic:	return b2_kinematicBody;
		}
		KG_CORE_ASSERT(false, "Unknown body type");
		return b2_staticBody;
	}

	inline static Rigidbody2DComponent::BodyType Rigidbody2DTypeFromBox2DBody(b2BodyType bodyType)
	{
		switch (bodyType)
		{
		case b2_staticBody:		return  Rigidbody2DComponent::BodyType::Static;
		case b2_dynamicBody:	return  Rigidbody2DComponent::BodyType::Dynamic;
		case b2_kinematicBody:	return  Rigidbody2DComponent::BodyType::Kinematic;
		}
		KG_CORE_ASSERT(false, "Unknown body type");
		return Rigidbody2DComponent::BodyType::Static;
	}
}
