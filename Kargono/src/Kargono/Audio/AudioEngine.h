#pragma once

#include "Kargono/Core/Base.h"

#include <glm/glm.hpp>

#include <queue>
#include <string>

struct ALCdevice;
struct ALCcontext;

namespace Kargono
{

	class AudioBuffer;

	struct AudioSourceSpecification
	{
	public:
		glm::vec3 Position{};
		glm::vec3 Velocity{};
		float Pitch{1.0f};
		float Gain{1.0f};
		bool IsLooping{false};
		Ref<AudioBuffer> CurrentBuffer{nullptr};
	};

	struct AudioListenerSpecification
	{
	public:
		glm::vec3 Position{};
		glm::vec3 Velocity{};
		glm::vec3 Forward{1.0f, 0.0f, 0.0f};
		glm::vec3 Up{};
	};

	//============================================================
	// Audio Listener Class
	//============================================================
	// This class represents the object that receives sound from AudioSources.
	//		Ex: An audio listener could be linked to the player character when
	//		a collision occurs. The source (the player being smacked with a rock)
	//		will produce a sound that the listener picks up. The algorithms that
	//		enable this process are encapsulated inside the OpenAL.
	class AudioListener
	{
	public:
		AudioListener() = default;
	private:
		uint32_t m_ListenerID{ 0 };
	};
	//============================================================
	// Audio Buffer Class
	//============================================================
	// Finalized format for audio that can be attached to an AudioSource
	//		and played.
	//		Ex: A test.wav file can be loaded in as PCM data and loaded into
	//		and AudioBuffer. The AudioBuffer is now usable in the OpenAL context
	//		to be played!
	class AudioBuffer
	{
	public:
		uint32_t m_BufferID {0};
	public:
		AudioBuffer() = default;
		AudioBuffer(const std::string& fileLocation);
		~AudioBuffer();
	private:
	};
	//============================================================
	// Audio Source Class
	//============================================================
	// An audio source is a structure that represents the location where
	//		audio is originated from. The AudioListener class will hear audio
	//		generated by and AudioSource.
	class AudioSource
	{
	public:
		AudioSource();
		~AudioSource();
	public:
		uint32_t& GetSourceID() { return m_SourceID; }
	private:
		uint32_t m_SourceID = 0;
	};
	//============================================================
	// Audio Context Class
	//============================================================
	// This class represents the underlying context and lifecycle of the
	//		audio engine. Starting and closing the audio engine is tied
	//		to this class's lifetime.
	class AudioEngine
	{
	public:
		static void Init();
		static void Terminate();
		static void PlayStereoAudio();
		static void PlaySound(const AudioSourceSpecification& sourceSpec, const AudioListenerSpecification& listenerSpec = {});
		static void PlaySound(Ref<AudioBuffer> audioBuffer);
		static void StopAllAudio();
	public:
		AudioEngine() = default;
	private:
		std::string m_CurrentDeviceName {};
		ALCdevice* m_CurrentDeviceID = nullptr;
		ALCcontext* m_ContextID = nullptr;
		Scope<AudioListener> m_DefaultListener = nullptr;
		std::queue<Ref<AudioSource>> m_AudioSourceQueue{};
		Scope<AudioSource> m_StereoMusicSource = nullptr;
	private:
		static AudioEngine* s_AudioContext;
	};
}
